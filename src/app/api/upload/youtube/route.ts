import { NextRequest, NextResponse } from 'next/server';
import { db } from '@/db';
import { videos } from '@/db/schema';
import { eq } from 'drizzle-orm';
import { uploadToYouTube } from '@/services/youtube';

export async function POST(request: NextRequest) {
    try {
        const { videoId, title, description, tags, privacyStatus } = await request.json();

        if (!videoId) {
            return NextResponse.json(
                { error: 'Video ID is required' },
                { status: 400 }
            );
        }

        console.log(`ðŸ“¤ Uploading video ${videoId} to YouTube...`);

        // Get the video from database
        const video = await db.query.videos.findFirst({
            where: eq(videos.id, videoId),
        });

        if (!video) {
            return NextResponse.json(
                { error: 'Video not found' },
                { status: 404 }
            );
        }

        // Check if already uploaded
        if (video.uploadStatus === 'completed' && video.youtubeId) {
            return NextResponse.json({
                success: true,
                message: 'Video already uploaded to YouTube',
                youtubeId: video.youtubeId,
                youtubeUrl: video.youtubeUrl,
            });
        }

        // Update status to uploading
        await db.update(videos)
            .set({ uploadStatus: 'uploading' })
            .where(eq(videos.id, videoId));

        // Download the video from Vercel Blob
        console.log('ðŸ“¥ Downloading video from:', video.url);
        const videoResponse = await fetch(video.url);

        if (!videoResponse.ok) {
            throw new Error(`Failed to download video: ${videoResponse.status}`);
        }

        const videoBuffer = Buffer.from(await videoResponse.arrayBuffer());
        console.log(`ðŸ“¦ Video size: ${(videoBuffer.length / 1024 / 1024).toFixed(2)} MB`);

        // Upload to YouTube
        const uploadResult = await uploadToYouTube(videoBuffer, {
            title: title || `PocketRot Video ${videoId}`,
            description: description || video.prompt || 'Generated by PocketRot',
            tags: tags || ['PocketRot', 'AI Generated', 'Short Film'],
            privacyStatus: privacyStatus || 'private',
        });

        if (!uploadResult.success) {
            // Update database with error
            await db.update(videos)
                .set({
                    uploadStatus: 'failed',
                    uploadError: uploadResult.error,
                })
                .where(eq(videos.id, videoId));

            return NextResponse.json({
                success: false,
                error: uploadResult.error,
            }, { status: 500 });
        }

        // Update database with YouTube info
        await db.update(videos)
            .set({
                youtubeId: uploadResult.videoId,
                youtubeUrl: uploadResult.videoUrl,
                uploadStatus: 'completed',
                uploadedAt: new Date(),
                uploadError: null,
            })
            .where(eq(videos.id, videoId));

        console.log('âœ… Video uploaded successfully to YouTube');

        return NextResponse.json({
            success: true,
            youtubeId: uploadResult.videoId,
            youtubeUrl: uploadResult.videoUrl,
        });

    } catch (error: any) {
        console.error('âŒ Error uploading to YouTube:', error);

        // Try to update database with error if we have a videoId
        const body = await request.json().catch(() => ({}));
        if (body.videoId) {
            await db.update(videos)
                .set({
                    uploadStatus: 'failed',
                    uploadError: error.message,
                })
                .where(eq(videos.id, body.videoId))
                .catch(console.error);
        }

        return NextResponse.json(
            { error: 'Failed to upload to YouTube', details: error.message },
            { status: 500 }
        );
    }
}
